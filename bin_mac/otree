#!/usr/bin/awk -f
# headn : if set to 1, then the first record is a header
# id, pid, info : strings in the header matching id, parent id, and info
# idn, pidn, infon : parameter numbers otherwise
# with : an id to include in the tree
NR == headn {
	j=3

	if (idn) j--
	if (pidn) j--
	if (infon) j--

	for (i=1; i <= NF; i++) {
		if (!idn && $i == id) {
			idn=i

			if (j-- == 1) next;
		} else if (!pidn && $i == pid) {
			pidn=i

			if (j-- == 1) next;
		} else if (!infon && $i == info) {
			infon=i

			if (j-- == 1) next;
		}
	}
}

{
	# save parent id
	pida[$idn]=$pidn

	# add to the list children for the parent id
	if (cidan[$pidn]) {
		cidan[$pidn]++
		cida[$pidn]=cida[$pidn] $idn " "
	} else {
		cidan[$pidn]=1
		cida[$pidn]=$idn " "
	}

	# This block finds the beginning of the info string
	j=0
	last=0
	n=length($0)
	for (i=1; i <= n; i++) {
		a=substr($0, i, 1)

		# last is 0 for FS, 1 otherwise
		if (split(a, b) == last)
			continue

		if (last) {
			last=0
			continue
		} else {
			last=1
		}

		if (++j >= infon)
			break
	}

	# tuck away all of the info string
	infoa[$idn]=substr($0, i)

	# tuck away the id in an orderred list starting from 1
	ida[NR]=$idn
}

END {
	# find the root of the tree containing with
	i=with
	while (j=pida[i]) {
		cida[j]=i " "
		i=j
	}

	# There may be no children of i, we need to create a stack
	# thath includes all roots then.
	stack[0]=cida[i]
	if (!stack[0]) {
		stack[0]=""
		for (i=2; i <= NR; i++) {
			j=ida[i]

			j=pida[j]
			if (pida[j])
				continue

			if (seen[j])
				continue

			seen[j]=1
			stack[0]=stack[0] j " "
		}
	}

	# Real awk does not allow us to define functions, so we use
	# arrays of lists as a stack instead of recursive functions.
	j=0
	while (j != -1) {
		i=index(stack[j], " ")
		if (i >= 1) {
			id=substr(stack[j], 1, i - 1)
			stack[j]=substr(stack[j], i + 1)

			for (i=0; i < j; i++)
				printf("  ")

			print id, infoa[id]

			if (cidan[id]) {
				j++
				stack[j]=cida[id]
			}
		} else {
			j--
		}
	}
}
